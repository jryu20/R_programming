---
title: "Stats 20, S22A -- Homework 4"
author: "Jun Ryu -- 605574052"
date: "`r format(Sys.Date(), '%D')`"
output:
  html_document:
    toc: yes            # creates table of contents
    toc_depth: 4        # toc will include headers <= ####
    toc_float: yes      # toc always on left of page
    code_folding: show  # allows hiding of code
---

## Question 1

```{r}

my_which <- function(x, arr.ind = FALSE) {
  result <- numeric(0)
  if(!arr.ind) {
    if(is.null(attributes(x))) {
      for (i in 1:length(x)) {
        if (x[i] == TRUE) {
          result <- c(result,i)
        }
      }
    } else {
      for (j in 1:ncol(x)) {
        for (i in 1:nrow(x)) {
          if (x[i,j] == TRUE) {
            result <- c(result, (j-1)*nrow(x)+i)
          }
        }
      }
      
    } 
  } else {
    if(is.null(attributes(x))) {
      for (i in 1:length(x)) {
        if (x[i] == TRUE) {
          result <- c(result,i)
        }
      }
    } else {
      for (j in 1:ncol(x)) {
        for (i in 1:nrow(x)) {
          if (x[i,j] == TRUE) {
            entry <- cbind("row" = i, "col" = j)
            result <- rbind(result, entry)
          }
        }
      }
      
    } 
  }
  result
}

which(matrix(c(TRUE, FALSE), nrow=4,ncol=3), arr.ind = TRUE)
my_which(matrix(c(TRUE, FALSE), nrow=4,ncol=3), arr.ind=TRUE)

```


## Question 2

### (a)

```{r}
char <- c("2", "1", "0")
num <- 0:2
charnum <- data.frame(char, num, stringsAsFactors = TRUE)

charnum$char
as.numeric(char)
as.numeric(charnum$char)
```

There is a difference in these results because when we run charnum$char, since stringsAsFactors is toggled on, we are returned with a factor with values 2, 1, and 0 in it. Thus, if we try to apply as.numeric to this, it gives us how the levels of this factor is stored in R, which is 3, 2, and 1, which is different from when we normally apply as.numeric to a character vector with numeric characters.  

### (b)

```{r}

as.numeric(as.character(charnum$char))

```

## Question 3

### (a)

```{r}

simple_list <- list("vector" = 1:10, "matrix" = matrix(6:1, nrow = 3, ncol = 2))
```

1. cannot use NULL as the name of the component because the console will read it as if you are not trying to add any component

2. cannot use NULL for assignment either because the console will read it as if you are not assigning anything

### (b)

```{r}

simple_list <- list("vector" = 1:10, "matrix" = matrix(6:1, nrow = 3, ncol = 2))
simple_list$list <- list(NULL)
length(simple_list) == 3
simple_list


```

### (c)

```{r}

simple_list[1] <- list(NULL)
simple_list

```

## Question 4


```{r}

my_scale <- function(x) {
  if (!is.null(attributes(x))) {
    att <- attributes(x)
    z <- att$a + (((x - min(x))*(att$b-att$a))/(max(x)-min(x)))
  } else {
    z <- (x - min(x))/(max(x)-min(x))
  }
  
  attributes(z) <- list("a" = x[1], "b" = x[length(x)])
  z
}

x <- c(3,5,9)
attributes(x) <- list("a" = 4, "b" = 6)
my_scale(my_scale(x))
```


## Question 5

### (a)

#### (i)

```{r}
load("mlb.RData")
tapply(hit, team, max)
```

#### (ii)

```{r}
table(team)
```

#### (iii)

```{r}
tapply(hr >= 1, team, sum)
```

### (b)

#### (i)

```{r}
tapply((hit[ab >= 100]/ab[ab >= 100]), team[ab >= 100], max)

```

#### (ii)

```{r}
tapply(hit, team, mean)/tapply(ab, team, mean)

```

### (c)

```{r}
tapply(hr, list(pos,league), mean)

```

Rightfield position has the biggest difference between the 2 leagues.

### (d)

```{r}

apply(tapply(pos, list(team, pos), length), 2, median)

```

## Question 6

### (a)

Write a function called inverse_2d that inputs a 2 by 2 matrix A and outputs the inverse of that matrix without using solve(). You should throw an error if the input is not a 2 by 2 matrix (including scalars, vectors, etc.) or if the input is a singular matrix. The output of inverse_2d() and solve() should be identical for any 2 by 2 matrix A.

My Solution:

```{r}

inverse_2d <- function(A) {
  if (is.null(dim(A)) || nrow(A) != 2 || ncol(A) != 2) {
    stop("Your input must be a 2 by 2 matrix.")
  }
  
  det <- A[1,1]*A[2,2] - A[1,2]*A[2,1]
  if(det == 0) {
    stop("The matrix is singular!")
  }
  
  B <- rbind(c(A[2,2],-A[1,2]),c(-A[2,1],A[1,1]))
  result <- (1/det)*B
  result
  
}

```

### (b)

Below, we have a function that attempts to output the trace (sum of the elements of the main diagonal) of a square matrix. Explain all the errors in the following code and how to correct them individually.

```{r}

matrix_trace <- function(A) {
  if (ncol(A) != nrow(A)) {
    stop("Your input must be a square matrix.")
  }
  
  i <- 1
  tr <- 0
  while (i < nrow(A)) {
    tr <- tr + A[i]
    i <- i + 1
  }
  
  tr
}

```

Error #1: The error condition does not check for scalar or vector inputs, and thus does not throw the proper error when a scalar or vector is inputted. In order to fix this, we must check for the dimension of the input and make sure it is not null.

Error #2: The condition of the while loop is not correct, causing it to run one less than it is expected to. To fix this, we need to change it to <= instead of <.

Error #3: The indexing of the matrix A is not correct. A[i] does not return values on the main diagonal; A[i,i] does.


Fixed Code:
```{r}

matrix_trace <- function(A) {
  if (ncol(A) != nrow(A) | is.null(dim(A))) {
    stop("Your input must be a square matrix.")
  }
  
  i <- 1
  tr <- 0
  while (i <= nrow(A)) {
    tr <- tr + A[i,i]
    i <- i + 1
  }
  
  tr
}

```

## Question 7

### (a)

```{r}

my_unlist <- function(x) {
  result <- logical(0)
  j <- 1
  for (i in 1:length(x)) {
      
    result[j:(j+length(x[[i]])-1)] <- x[[i]]
    j <- j + length(x[[i]])
  }
  
  result
}
  
x <- list(c(2, 1, 1), c(3, 2, 1), 2)
my_unlist(x)
my_unlist(list(factor(c("a", "b")), c(1, 2)))
```




